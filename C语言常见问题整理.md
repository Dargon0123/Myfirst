 [TOC]
# 变量类型问题
## 01 static的作用？
* @Author：dargon
* @Date   ：2021/07/10


1. 全局静态变量
    1. 在全局变量前加 static 关键字，该变量被定义为 全局静态变量
        1. 内存中的位置，静态存储区（整个程序运行期间都会存在）
        2. 初始化的时候，未指定数值会被程序默认初始化为0，而auto（可省略的）则会被初始化成任意的。
        3. 作用域，在声明它的文件之外是不可见的，从定义该变量开始到该文件结束都是它的作用域，其它文件中可以使用相同名字的变量，不会冲突。
    2. 好处
        1. 不会被其它的文件所访问，修改，只能是自己所在定义的文件里面使用。
        2. 其它文件中，可定义相同的变量名字。
    3. 改变了全局变量的作用域，但是没有改变变量的存储位置，全局都存储在静态存储区内。
    4. 感觉类似C++中的private，不对外部开放的东西。
2. 局部静态变量
    1. 定义：一般在函数中的变量为局部变量，加上static 就是局部静态变量了
        1. 内存中的位置，静态存储区（整个程序运行器件都会存在）,**全局/静态存储区和执行代码一样，在编译过程中，就已经生成在执行文件中了，在由操作系统直接映射到内存中，局部静态变量在程序运行时创建到静态内存区域，此后一直持续到运行结束时候，再消失。**
        2. 初始化的时候，同上
        3. 作用域，只在定义的函数内有用。
    2. 和普通局部变量区别：
        1. 改变该局部变量的存储位置，从堆栈中改到 静态存储区域，其离开作用域之后，并没有被销毁，会一直存储在静态存储区域，直到程序结束，只不过是都不能进行访问。
3. 静态函数
    1. 静态函数不能被其它文件所使用
    2. 其它文件中可以定义相同名字的函数
4. 总结：
    1. 第一个 隐藏，相对于其它文件是不可见的
    2. 第二个 变量的内容储存持久，一直储存在静态变量区域，且static变量，只进行一次的初始化


## 02 volatile 类型的作用？

1. C语言中关于 volatile 数据类型的解释：
    1.  volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存地址读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。
    2.  （简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）
2.  使用volatile的场景
    1.  中断服务程序中修改的供其它程序检测的变量需要加volatile
    2.  多任务环境下各任务间共享的标志应该加volatile
    3.  存储器映射的 **硬件寄存器** 通常也要加voliate，因为每次对它的读写都可能有不同意义
3.  合理使用volatile 过多使用导致程序变慢 不合理
4.  关于使用volatile的问题
5.  
* 一个参数既可以是const还可以是volatile吗？
    可以的，例如只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。

* 一个指针可以是volatile 吗？
    可以，当一个中服务子程序修该一个指向一个buffer的指针时。
    

1. 编译器的优化，在用到这个变量时，必须每次都小心地重新读取这个变量在内存中的位置，而不是使用保存在寄存器里的备份（虽然读写寄存器比读写内存快些）

## 03 const 类型的作用？

1. const 用来修饰变量，函数形参和成员函数
    1. const修饰常量：定义时就初始化，以后不能更改。
    2. const修饰形参：func(const int a){};该形参在函数里不能改变，对于传进来的形参，我只是让你这个函数用这个变量值，不允许你对这个变量做任何的更改。或者赋值操作
    3. const修饰类成员函数：函数对其成员变量进行只读操作，就是 const类成员函数是不能修改成员变量的数值的。
2. 被const修饰的东西都受到**强制保护，可以预防意外的变动**，能提高程序的健壮性。
3. 修饰常量，代表着“只读的”概念
4. 
```cpp
const int a;
int const a; // 和前一个是一样的都表示 a 是一个常整形数
const int *a; // 表示a 是一个指向 常 整形数的指针，指针所指的常整形数是不可以修改的，但是指针可以修改。
int* const a; // 表示a 是一个指向整形数的 常 指针，指针指向的整形数是可以修改的但是指针是不可以修改的。
int const *a const; // 表示a 是一个指向 常 整数型的 常 指针，（指针指向的整形数是不可以修改的，指针也是不可以修改的）
```

## 04 const和#define 的区别（编译阶段、安全性、内存占用）两者进行对照着来看。

1. 用#define max 100；
    1. 定义的常量是没有数据类型的
    2. （不进行安全检查，会发生意想不到的错误）。
    3. 所给出的是一个立即数，编译器只是把所定义的常量值与所定义的常量的名字联系起来，所定义的宏变量 macro在 **预处理** 阶段的时候进行替换，**在程序中使用到该常量的地方都要进行拷贝替换。**
2. 用 const int max =100；
    1. 定义的常量是带有数据类型的，比如这个是int整形的。
    2. 编译是安全，会进行类型检查。
    3. 变量存放静态存储区域内，在 **编译** 时进行值的确定。**程序运行过程中const变量只有一个拷贝**，而#define macro定义有多个拷贝，所以宏定义在程序运行过程中所消耗的内存要比const 变量大得多。


## 05 变量作用域（全局变量和局部变量）

1. 全局变量
    1. 在所有函数体的外部定义的，程序的所在部分都可以使用。全局变量不受作用域的影响（也即是，全局变量的生命期一直到程序结束）。
2. 局部变量
    1. 出现在一个作用域内，局限于一个函数内。经常被称为自动变量，因为他们进入作用域内自动生效，离开作用域内自动消失。局部变量默认是auto类型的，所以没有必要声明为auto类型的。
3. 局部变量和全局变量可以重名，重名的情况下，在局部变量作用范围内，全局变量失效，采用的是局部变量的值。

## 06 局部变量未定义时的值，是随机的吗？这时，栈的工作方式？

1. 未初始化的局部变量值是不确定的，但不是一个随机数，相当于一个伪随机数，
2. 定义局部变量的时候，其实就是在栈中通过移动sp 栈指针（指向的栈空间的栈顶）来给程序提供一个内存空间和这个局部变量名绑定，由于这个局部空间在栈上，栈的内存空间是重复利用的（脏内存，可能上次用完没有清零），所以当使用栈来实现的局部变量未初始化的时候，可能里面的值是上一次没有初始化的值，是一个垃圾值。但不是随机值。
3. 栈是利用一个栈指针（sp：始终指向栈顶的地址）向下生长（想象一下向下压push的过程就可以，从高到低生长，堆是从低到高的方式），先进后出的工作方式。

## 07 栈的角度理解函数调用过程？连续调用同一个函数两次，局部变量初始化结果是否一致？

1. 参数入栈：将函数参数从右向左依次压入系统栈中（**最后恢复现场的时候再弹出来，这里也说明，对于函数仅仅传值进去的话，函数用完之后，不会改变变量的状态**）
2. 函数返回地址入栈：PC指针的下一条指令入栈，以便调用的函数执行完后返回是继续接着执行。（先保护现场，把相应的寄存器状态，以及参数进行入栈）
3. 代码区跳转：跳到被调用函数的地址入口，
4. 栈帧调整：（这里面是不太清楚）
5. 然后函数内部的局部变量压入自己的栈帧。
6. 调用完函数之后，然后恢复现场（PC回地址，返回当时传入的参数）
7. 



1. 连续调用同一个函数的话，局部变量的初始化可能会一样，如果之前内存里面内容没有清除的话，如果局部变量还是使用的原来的栈区的内存位置，那么就是没有变化。
2. 程序结束时，系统会把整个进程的内存全部统一回收。程序进行中，函数返回的时候，栈指针下移就可以，**高于栈指针的内存被视为空的**，下次在调用其它函数时候，也同样的会调整栈帧，到时候再压上去就行。

    
   
    
   
# 内存分配类型问题
## 01 new和malloc 区别

## 02 在1G内存的计算机中能否malloc(1.2G)？为什么？（2021浙江大华二面问题）

1. 是有可能申请1.2G 的内存的
2. **解析：回答这个问题前需要知道malloc的作用和原理，应用程序通过malloc函数可以向程序的虚拟空间申请一块虚拟地址空间，与物理内存没有直接关系，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。**
3. malloc的使用说明，返回的是一个指向被分配的内存块起始位置的指针，所分配的是一块连续的内存，未初始化，并且初始化只能用 memset（）函数初始化
4. 可以malloc出来，但是当你初始化的时候会发生错误。
    1. 原因是每一个进程都先天设定了4G的虚拟空间地址（不是真实地址，只是一个编号），虚拟内存开始时，不对应任何的物理地址。虚拟内存地址必须映射到物理内存的（或者硬盘上的文件）才能存储数据（数据存储在物理内存上，打印的数据地址，是虚拟内存的地址），实际上内存分配以及初始化的过程，就是建立虚拟地址与实际物理内存地址的映射关系，free 内存回收则是解除这种映射的关系。
    2. 这样就很清晰了，可以申请这个大空间，但是你不能初始化啊

## 03 extern”C” 的作用

也就是extern“C” 都是在c++文件里添加的。

extern在链接阶段起作用（四大阶段：预处理--编译--汇编--链接）。

## 04 strcat、strncat、strcmp、strcpy哪些函数会导致内存溢出？如何改进？

1. 
```cpp
// 没有判断目的地址 是否够用
char *strcpy（char *strDest，const char *strSrc）

// 没有检查目标大小的边界
strncpy(dest, src, sizeof(dest)); 
```

## 05 **sizeof 与strlen** （字符串，数组）

1. sizeof（）：是一个操作符（单目操作符），不是一个函数，返回一个对象/类型所占的内存字节数
    1. 数组名一般用指针常量来表示，只有在两种场合下，数组名并不用指针常量来表示
        1. 遇见数组
        2. 取一个数组名的地址时，所产生的是一个指向数组的指针，而不是某个指向指针常量值的指针。
```cpp
int a[10];
sizeof(a) ; // 这里的a 表示整个数组，输出结果是数组的所占的内存长度
sizeof(*a) ; // 数组a 的第一个元素的长度
```
>二.用sizeof求一个字符串分为几种情况：

>A.\后面一般跟的是八进制数如 \000 \377 \378
>
>B.\也可跟16进制如\x11 \xff
>
>C.\后面跟的字符如\a \A \8
>
>如下字符串举例：
>
>"\0000" 可以看成\000 0 \0 ，sizeof 值为3，第一个\000代表ascii第一个元素（NULL空操作），第二个0是字符0，最后红色的\0是系统自带\0（他实际也是\0,\00,\000 也就是ASCII所代表的第一个元素NULL）用于结束字符串。所以sizeof就是3
>
>
>
>"\3770" 可以看成\377 0 \0 ，sizeof 值为 3，第一个代表\377（注意此时的377是一个8进制数转换成十进制是255,刚好是一个字符所能表示的最大数字，一个字符占一个字节，一字节= 8位，每一位可用01表示，所以一个字符所能表示的最大范围是2^8=256 0~255）, 第二个0是字符0，最后红色的\0是系统自带\0（他实际也是\0,\00,\000 也就是ASCII所代表的第一个元素NULL）用于结束字符串。所以sizeof就是3
>
>
>
>"\378" 可以看成\37 8 \0 , sizeof值为3，如果\后面没有x（注意是小写x,大写X的话是算字符X）,所以\378就是八进制，但是八进制怎么可能出现8呢？ 所以真确理解方式应该是 \037 8 \0 ,第一个\037代表ASCII第37个元素，第二个8是字符8，第三个\0是系统自带，所以sizeof就是3
>————————————————
>进一步理解

\8就是字符8, \7不是字符7而是ASCII为7所对应的元素
到这里就可以理解转义字符\的含义了：就是把ASCII编码转换成该编码所对应的字符。
版权声明：本文为CSDN博主「littesss」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/littesss/article/details/72782954 **这篇文章总结的很细致**
        
2. strlen() 仅对字符串有效，知道‘\0’为止，计数结果不包括\0 结束符
    1. strlen “\n\t\tag\AAtang”=11
    2. \n 代表一个字节 \t 代表一个字节 \t a g \A A t a n g \0
    3. \A 就相当于字符 ‘A’\65 对应的ascll码值
    4. \000 相当于 \0 \00 \000 \x000000000 对应的ascll码编号为0，对应的字符是nul 空操作
    5. \7 代表着ascll序列为7所对应的元素， \后面是一个八进制数
    6. \8 是字符8 (因为八进制不能表示8)，看成是 \56 
3. 对于sizeof() 操作符的运算就是，\0 字符串的结束符也算作在内的
   

## 06 位域（bit field）概念

1. 优点
    1. 把长度为奇数的数据包装在一起，节省存储空间。
    2. 便于一个整形值的部分内容，在寄存器的位操作里面使用很方便。
        1. 同样的，能用位段实现的任务都可以使用移位和屏蔽来实现
    3. 位段使用可以简化源代码，但是移植性不好。


## 07 inline 函数

1. 在C 语言中，一些函数被频繁调用，不断有函数入栈，会造成栈空间或是 栈内存的大量消耗。为了解决这种频繁调用问题，特别的引入inline 修饰符，表示为 内联函数。
2. ，在大多数机器上，一次函数的调用包含着一系列的工作：调用前要先保存寄存器，并在返回时恢复；可能要拷贝实参；程序转向一个新的位置继续执行；等
3. inline 函数可避免频繁调用函数的开销。内联也只是说明项编译器发出的一个请求，编译器也可以选择忽略这个请求。


## 08 内存五区 什么变量分别存储在什么区域，堆上还是栈上。

1. 栈区
    1. 向下增长；向低地址方向增长（扩展），如`%rsp +0x26, %rsp`
    
       |   内容   |     地址     |
       | :------: | :----------: |
       |          | `%rsp +0x20` |
       |          | `%rsp +0x18` |
       |          | `%rsp +0x10` |
       |          | `%rsp +0x08` |
       | @#%￥……% | `%rsp +0x00` |
    
    2. 存放函数的参数值、返回值、局部（易变的 或者不变的）变量的开销等等
    
    3. 先入先出的特点，特别方便用来保存，恢复上下文的现场，其实可以看作是一个临时数据的内存交换的场所。
    
    4. `csapp`描述栈区的功能：栈帧结构
    
       * 传递参数
       * 存储返回信息
       * 保存寄存器
       * 局部存储
       * ……
    
2. 堆区
    1. 向上增长，向低地址方向增长（扩展）
    2. 用于动态内存分配，比如说new  malloc 空间，当malloc回来内存空间时就动态分配到堆上，当利用free等函数释放内存时，被释放的内存从堆中剔除。
    
3. 代码区和数据区（全局区、静态区）
    
    1. `.text`
        * 已编译程序的机器代码
    2. `.rodata`
        * 只读数据，比如`printf`语句中的格式串，开关语句的跳转表
    3. `.data`
        * 初始化数据区，已初始化的全局变量和已初始化的为非`0`的静态变量一块内存区域，属于静态内存分配。直观理解就是C语言程序中的全局变量
    4. 未初始化数据 `.bss`区，`Block Storage Start`也称`Better save space`的缩写
        * 全局未初始化数据变量
        * 静态未初始化数据变量，全局/局部
        * 以及所有被初始化为`0`的全局或静态变量
    
    

## 09 使用32位编译情况下，给出判断使用的机器大小端的方法

1. 大小端含义例如 int a =1的存储方式，内存地址从低到高。
    1. 小端  的存储 为01 00 00 00
    2. 大端  的存储 为00 00 00 01
2. 判断方法
    1. union 的方式判断
    2. 指针的方式判断
        1. 通过将int强制类型转换成char单字节，p指向a的起始字节（低字节）

## 10 struct和union 的内存对齐问题

1. 内存对齐分为自然对齐和规则对齐
    1. 预编译命令#pragma pack(n)

    